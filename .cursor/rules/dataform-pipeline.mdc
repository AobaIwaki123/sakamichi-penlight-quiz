---
description: "DataformデータパイプラインとBigQueryテーブル定義"
globs: definitions/**,**/*.sqlx,**/*.js
---

# Dataform・SQLデータパイプラインガイド

## Dataform プロジェクト構成

### ディレクトリ構造
```
definitions/
├── sources/              # 生データソース定義
│   ├── hinatazaka/      # 日向坂46データ
│   │   ├── member_info.js
│   │   ├── penlight.js
│   │   └── member_image_*.js
│   └── sakurazaka/      # 櫻坂46データ
│       ├── member_info.js
│       ├── penlight.js
│       └── member_image_*.js
├── intermediate/         # 中間処理テーブル
│   ├── hinatazaka/
│   │   ├── member_image_master.sqlx
│   │   ├── member_with_image.sqlx
│   │   └── member_master.sqlx
│   └── sakurazaka/
│       └── ... (同様の構成)
└── output/              # 最終出力テーブル
    └── sakamichi/
        ├── hinatazaka_member_master.sqlx
        ├── hinatazaka_penlight.sqlx
        ├── sakurazaka_member_master.sqlx
        └── sakurazaka_penlight.sqlx
```

## データフロー設計

### 3層アーキテクチャ
1. **ソース層**: 生データの取り込み
2. **中間層**: データクレンジング・結合処理
3. **出力層**: アプリケーション向け最終テーブル

### データ依存関係
```
sources/member_info.js
sources/penlight.js        →  intermediate/member_master.sqlx
sources/member_image_*.js  →  intermediate/member_image_master.sqlx
                          →  intermediate/member_with_image.sqlx
                          →  output/hinatazaka_member_master.sqlx
```

## SQLXファイル規約

### 基本構造
```sql
-- config block（必須）
config {
  type: "table",           -- table, view, incremental
  schema: "sakamichi",     -- データセット名
  name: "hinatazaka_member_master",  -- テーブル名
  description: "日向坂46メンバー情報のマスターテーブル",
  
  -- オプション設定
  partition: "created_at", -- パーティション設定（日付カラム）
  cluster: "id, gen"       -- クラスタリング設定
}

-- SQLクエリ部分
SELECT
  -- カラム定義とコメント
  info.id,                    -- メンバーID
  info.name,                  -- メンバー名
  info.nickname,              -- ニックネーム
  info.emoji,                 -- 代表絵文字
  info.gen,                   -- 所属期生
  info.graduated,             -- 卒業状態
  penlight1.id AS penlight1_id, -- ペンライト色1のID
  penlight2.id AS penlight2_id, -- ペンライト色2のID
  info.type,                  -- 画像タイプ
  info.url                    -- 画像URL
FROM
  ${ref("member_with_image")} info
JOIN
  ${ref("penlight")} penlight1 ON info.penlight1 = penlight1.name_ja
JOIN
  ${ref("penlight")} penlight2 ON info.penlight2 = penlight2.name_ja
```

### 参照構文（Dataform ref）
```sql
-- 同一スキーマ内の参照
${ref("table_name")}

-- 異なるスキーマの参照
${ref("schema_name", "table_name")}

-- ソースデータの参照
${ref("hinatazaka", "member_info")}
```

## ソースデータ定義

### JavaScriptソースファイル
```javascript
// sources/hinatazaka/member_info.js
const member_info = [
  {
    id: 1,
    name: "潮紗理菜",
    nickname: "しお",
    emoji: "🧂",
    gen: "1st",
    graduated: false,
    penlight1: "青",        // 日本語色名（結合キー）
    penlight2: "空色"       // 日本語色名（結合キー）
  },
  // ... 他のメンバー
];

// 必須エクスポート
module.exports = member_info;
```

### ペンライトマスターデータ
```javascript
// sources/hinatazaka/penlight.js
const penlight = [
  {
    id: 1,
    name_ja: "青",
    name_en: "blue",
    color: "#0066ff"         // HEX色コード
  },
  {
    id: 2,
    name_ja: "空色",
    name_en: "sky_blue",
    color: "#87ceeb"
  },
  // ... 全ペンライト色
];

module.exports = penlight;
```

## 中間テーブル設計

### 画像マスター統合
```sql
-- intermediate/hinatazaka/member_image_master.sqlx
config {
  type: "table",
  schema: "hinatazaka",
  name: "member_image_master",
  description: "日向坂46メンバー画像情報の統合テーブル"
}

-- 複数の画像ソースを統合
SELECT id, name, type, url FROM ${ref("member_image_13th_single")}
UNION ALL
SELECT id, name, type, url FROM ${ref("member_image_5th_hinatansai")}
UNION ALL
SELECT id, name, type, url FROM ${ref("member_image_5th_member")}
```

### メンバー・画像結合
```sql
-- intermediate/hinatazaka/member_with_image.sqlx
config {
  type: "table",
  schema: "hinatazaka",
  name: "member_with_image",
  description: "メンバー情報と画像の結合テーブル"
}

SELECT 
  m.*,                      -- 全メンバー情報
  i.type,                   -- 画像タイプ
  i.url                     -- 画像URL
FROM 
  ${ref("member_master")} m
LEFT JOIN 
  ${ref("member_image_master")} i ON m.id = i.id AND m.name = i.name
```

## 最終出力テーブル

### アプリケーション向けマスターテーブル
```sql
-- output/sakamichi/hinatazaka_member_master.sqlx
config {
  type: "table",
  schema: "sakamichi",      -- 統一スキーマ
  name: "hinatazaka_member_master",
  description: "日向坂46メンバー情報の最終テーブル（アプリケーション用）"
}

SELECT
  info.id,
  info.name,                    -- メンバー名
  info.nickname,                -- ニックネーム  
  info.emoji,                   -- 代表絵文字
  info.gen,                     -- 所属期生
  info.graduated,               -- 卒業状態
  penlight1.id AS penlight1_id, -- ペンライト色1のID
  penlight2.id AS penlight2_id, -- ペンライト色2のID
  info.type,                    -- 画像タイプ
  info.url                      -- 画像URL
FROM
  ${ref("hinatazaka", "member_with_image")} info
JOIN
  ${ref("hinatazaka", "penlight")} penlight1 ON info.penlight1 = penlight1.name_ja  
JOIN  
  ${ref("hinatazaka", "penlight")} penlight2 ON info.penlight2 = penlight2.name_ja
```

### ペンライト色マスターテーブル
```sql
-- output/sakamichi/hinatazaka_penlight.sqlx
config {
  type: "table",
  schema: "sakamichi",
  name: "hinatazaka_penlight", 
  description: "日向坂46ペンライト色マスターテーブル"
}

SELECT
  id,
  name_ja,                      -- 日本語色名
  name_en,                      -- 英語色名
  color                         -- HEX色コード
FROM
  ${ref("hinatazaka", "penlight")}
ORDER BY
  id
```

## データ品質管理

### データバリデーション
```sql
-- 重複チェック
SELECT 
  name, 
  COUNT(*) as count
FROM ${ref("member_master")}
GROUP BY name
HAVING COUNT(*) > 1;

-- ペンライト参照整合性チェック  
SELECT 
  m.name,
  m.penlight1,
  m.penlight2
FROM ${ref("member_master")} m
LEFT JOIN ${ref("penlight")} p1 ON m.penlight1 = p1.name_ja
LEFT JOIN ${ref("penlight")} p2 ON m.penlight2 = p2.name_ja
WHERE p1.id IS NULL OR p2.id IS NULL;
```

### テストクエリ
```sql
-- アサーションテスト例
config {
  type: "assertion",
  name: "no_duplicate_members"
}

SELECT *
FROM ${ref("hinatazaka_member_master")}
GROUP BY id
HAVING COUNT(*) > 1
```

## スキーマ管理

### プロジェクト・データセット構成
- **開発環境**: `hinatazaka`, `sakurazaka` スキーマ
- **本番環境**: `sakamichi` 統一スキーマ
- **プロジェクト**: `sakamichipenlightquiz`

### 命名規則
- **テーブル名**: `{group}_member_master`, `{group}_penlight`
- **カラム名**: 英語（snake_case）
- **中間テーブル**: 目的を明確にした名前（`member_with_image`等）

## デプロイメント戦略

### ステージング vs 本番
```sql
-- 環境別設定の例
config {
  type: "table",
  schema: dataform.projectConfig.vars.target_schema || "sakamichi",
  name: "hinatazaka_member_master"
}
```

### インクリメンタル更新
```sql
-- 大量データの場合のインクリメンタル設定
config {
  type: "incremental",
  uniqueKey: ["id"],
  updateStrategy: "merge"
}

SELECT * FROM source_table
${ when(incremental(), `WHERE updated_at > (SELECT MAX(updated_at) FROM ${self()})`) }
```

## パフォーマンス最適化

### パーティション戦略
```sql
config {
  type: "table",
  partition: "created_date",  -- 日付でパーティション分割
  cluster: ["id", "gen"]      -- よく使われるカラムでクラスタリング
}
```

### クエリ最適化
- **JOIN順序**: 小さいテーブルを左側に配置
- **WHERE句**: パーティション条件を最初に記述
- **SELECT句**: 必要なカラムのみ選択

## エラーハンドリング

### 一般的なエラーパターン
1. **参照エラー**: `${ref()}` の誤った参照
2. **スキーマエラー**: 存在しないカラムの参照
3. **型エラー**: データ型の不一致
4. **結合エラー**: JOINキーの不整合

### デバッグ方法
```sql
-- データ確認用クエリ
SELECT 
  COUNT(*) as total_count,
  COUNT(DISTINCT id) as unique_ids,
  MIN(id) as min_id,
  MAX(id) as max_id
FROM ${ref("target_table")}
```

## ベストプラクティス

### SQL記述規約
1. **コメント**: 日本語でビジネスロジックを説明
2. **インデント**: 読みやすさを重視した整列
3. **カラム順序**: id, name等の基本情報を先頭に配置
4. **JOIN**: 明示的にINNER/LEFT JOINを記述

### データモデリング
1. **正規化**: 適度な正規化でデータ整合性を保つ
2. **非正規化**: アプリケーション性能を考慮した結合済みテーブル
3. **履歴管理**: 必要に応じて更新履歴を保持
4. **メタデータ**: created_at, updated_at等の管理カラム

### Git管理
1. **コミット単位**: 論理的な変更単位でコミット
2. **ブランチ戦略**: feature/table-name等の命名
3. **レビュー**: SQLロジックとパフォーマンスの観点でレビュー

## 監視・運用

### データ品質監視
- 日次でのレコード数チェック
- 参照整合性の監視
- 異常データの検出

### パフォーマンス監視  
- クエリ実行時間の監視
- BigQueryスロット使用量の確認
- パーティション効率性の評価
